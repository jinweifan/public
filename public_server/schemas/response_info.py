"""响应信息"""
from typing import Any, List, Optional

from fastapi import status
from pydantic import BaseModel, Field


class RespInfo(BaseModel):
    """返回信息体"""

    code: int = Field(..., description="具体错误代码")
    reason: str = Field(None, description="错误原因名称, e.g. NEED_PASSWORD")
    message: str = Field(None, description="错误详细信息，可用于显示")
    http_status: int = Field(status.HTTP_400_BAD_REQUEST, description="http 状态码")

    def __eq__(self: "RespInfo", other: object) -> bool:
        """Compare two : class : ` Error ` objects for equality. This is useful for determining if a test should be run on an error that is not expected to have been generated by the test code.

        Args:
                other: The other object to compare this error to.

        Returns:
                True if the objects are equal False otherwise.
        """
        return (
            isinstance(other, RespInfo)
            and other.code == self.code
            and other.reason == self.reason
        )

    def __hash__(self: "RespInfo") -> int:
        """Returns a hash of the error. Used to avoid collisions between different error classes. It is the same as the __hash__ method of the Error class except that it does not check the status code and reason of the error.

        Returns:
                The hash of the error as an int in the range 0 to 2147483647 ( inclusive ). This is a 32 - bit signed integer
        """
        return hash((self.http_status, self.code, self.reason))

    def __lt__(self: "RespInfo", other: "RespInfo") -> bool:
        """Compares two : class : ` Error ` objects for lexicographic ordering. This is used to determine whether a response should be considered less than another.

        Args:
                other: The other : class : ` Error ` to compare to.

        Returns:
                True if the first error is less than the second error False otherwise.
        """
        return (self.http_status, self.code, self.reason) < (
            other.http_status,
            other.code,
            other.reason,
        )

    def with_message(
        self: "RespInfo", message: str, reason: Optional[str] = None
    ) -> "RespInfo":
        """Return a copy of this error with the given message. This is useful for error messages that are different from the original.

        Args:
                message: The message to set. If this is None the original message is used.

        Returns:
                A copy of this error with the given message set. Note that the original error is not modified in any way
        """
        err = self.model_copy()
        err.message = message
        if reason is not None:
            err.reason = reason
        return err


class NMCException(Exception):
    """未满足条件 NoMeetConditionException"""

    def __init__(self: "NMCException", error: RespInfo, *args: List[Any]) -> None:
        """Initializes the exception with the given error. This is a convenience method for subclasses to use in place of __init__.

        Args:
                error: The error to set. It must be an instance of : class : ` Error `
                args: The arguments to pass to the constructor.

        Returns:
                The exception that was initialized with the given error and args.
        """
        super().__init__(*args)
        self.error: RespInfo = error


class RSINFO:
    """响应常规信息
    Code Pattern (AAA | XXXXYYZZ)
    服务和错误码编号 http://wiki.bigquant.ai/pages/viewpage.action?pageId=332731561

    0: 成功
    AAA: HTTP 状态码
    XXXX: 业务组
    YY: 错误组
    ZZ: 错误 ID
    """

    OK = RespInfo(
        code=0, reason="OK", message="请求成功", http_status=status.HTTP_200_OK
    )
    CREATED = RespInfo(
        code=0,
        reason="CREATED",
        message="创建成功",
        http_status=status.HTTP_201_CREATED,
    )
    REGISTERED = RespInfo(
        code=0,
        reason="REGISTERED",
        message="注册成功",
        http_status=status.HTTP_201_CREATED,
    )
    EXISTED = RespInfo(
        code=0,
        reason="EXISTED",
        message="已存在",
        http_status=status.HTTP_200_OK,
    )
    CONFLICT = RespInfo(
        code=409,
        reason="CONFLICT",
        message="请求的资源已存在",
        http_status=status.HTTP_409_CONFLICT,
    )
    UNKNOWN = RespInfo(
        code=99999999,
        reason="UNKNOWN",
        message="未知错误，请联系工作人员",
        http_status=status.HTTP_400_BAD_REQUEST,
    )
    REQUEST_VALIDATION_ERROR = RespInfo(
        code=99990400,
        reason="REQUEST_VALIDATION_ERROR",
        message="请求参数验证错误",
        http_status=status.HTTP_400_BAD_REQUEST,
    )
    RUNTIME_ERROR = RespInfo(
        code=99990500,
        reason="RUNTIME_ERROR",
        message="接口无返回值或接口请求已被取消",
        http_status=status.HTTP_400_BAD_REQUEST,
    )

    BAD_REQUEST = RespInfo(
        code=400,
        reason="BAD_REQUEST",
        message="请求参数错误",
        http_status=status.HTTP_400_BAD_REQUEST,
    )
    UNAUTHORIZED = RespInfo(
        code=401,
        reason="UNAUTHORIZED",
        message="没有身份验证凭证",
        http_status=status.HTTP_401_UNAUTHORIZED,
    )
    FORBIDDEN = RespInfo(
        code=403,
        reason="FORBIDDEN",
        message="没有访问内容的权限",
        http_status=status.HTTP_403_FORBIDDEN,
    )
    NOT_FOUND = RespInfo(
        code=404,
        reason="NOT_FOUND",
        message="找不到请求的资源",
        http_status=status.HTTP_404_NOT_FOUND,
    )

    @staticmethod
    def err(
        code: int,
        reason: str,
        message: str,
        http_status: int = status.HTTP_400_BAD_REQUEST,
    ) -> RespInfo:
        """Create and return an error. This is a convenience function for creating : class : ` Error ` objects that are used in tests.

        Args:
                code: The HTTP status code of the error. It is an integer from
                reason: The reason for the error. It is an string from
                message: The message associated with the error. It is a string from
                http_status: The HTTP status code to use for the error.

        Returns:
                An instance of : class : ` Error ` with the given fields filled in. code ( int ) : The HTTP status code of the error. reason ( str )
        """
        return RespInfo(
            code=code, reason=reason, message=message, http_status=http_status
        )


class RFInfo(RSINFO):
    """响应失败信息"""

    FAILED = RSINFO.err(10001111, "FAILED", "请求失败")
    USER_ALREADY_EXISTS = RSINFO.err(10001000, "USER_ALREADY_EXISTS", "用户已存在")
    USERNAME_INVALID_PATTERN = RSINFO.err(
        10001001,
        "USERNAME_INVALID_PATTERN",
        "用户名包含无效字符, 只能包含小写字母和数字, 以小写字母开头, 长度在4-64位之间",
    )
    PASSWORD_INVALID_PATTERN = RSINFO.err(
        10001002,
        "PASSWORD_INVALID_PATTERN",
        "密码至少包含一个大写字母, 一个小写字母, 一个数字, 一个特殊字符, 长度在8-64位之间",
    )

    AUTH_INVALID_USERNAME_OR_PASSWORD = RSINFO.err(
        10001003, "AUTH_INVALID_USERNAME_OR_PASSWORD", "用户名或密码错误"
    )
    AUTH_INVALID_SMS_CODE = RSINFO.err(10001003, "AUTH_INVALID_SMS_CODE", "验证码错误")
    AUTH_INVALID_USER_NOT_ACTIVE = RSINFO.err(
        10001004, "AUTH_INVALID_USER_NOT_ACTIVE", "当前用户不可用"
    )
    AUTH_INVALID_TOKEN = RSINFO.err(10001005, "AUTH_INVALID_TOKEN", "无效token")
    AUTH_INVALID_USER_NOT_FOUND = RSINFO.err(
        10001006, "AUTH_INVALID_USER_NOT_FOUND", "当前用户不存在"
    )
    AUTH_INVALID_USER_NO_PRIVILEGES = RSINFO.err(
        10001007, "AUTH_INVALID_USER_NO_PRIVILEGES", "当前权限不足"
    )
    AUTH_INVALID_TOKEN_EXPIRED = RSINFO.err(
        10001008, "AUTH_INVALID_TOKEN_EXPIRED", "token已过期"
    )
    AUTH_INVALID_PUBLIC_KEY = RSINFO.err(
        10001009, "AUTH_INVALID_JWT_PUBLIC_KEY", "无效的public key"
    )
    AUTH_IP_NOT_ALLOWED = RSINFO.err(10001010, "AUTH_IP_NOT_ALLOWED", "IP不允许访问")
    AUTH_INVALID_PROVIDER = RSINFO.err(
        10001011, "AUTH_INVALID_PROVIDER", "无效的认证方式"
    )
    NICKNAME_INVALID_PATTERN = RSINFO.err(
        10001012,
        "NICKNAME_INVALID_PATTERN",
        "用户昵称包含无效字符, 只能包含汉字，大、小写字母和数字，长度在0-64位之间",
    )

    INVALID_USERNAME_OR_PASSWORD = RSINFO.err(
        10002000, "INVALID_USERNAME_OR_PASSWORD", "错误的用户名或密码"
    )
    USER_IS_NOT_VERIFIED = RSINFO.err(
        10002001, "USER_IS_NOT_VERIFIED", "此用户尚未激活"
    )
    USER_IS_INACTIVE = RSINFO.err(10002002, "USER_IS_INACTIVE", "此用户已被停用")
    INVALID_PHONE_OR_CODE = RSINFO.err(
        10002003, "INVALID_PHONE_OR_CODE", "错误的手机号或验证码"
    )
    RE_OBTAIN_CODE = RSINFO.err(10002004, "RE_OBTAIN_CODE", "请重新获取手机验证码")
    CODE_EXPIRED = RSINFO.err(10002005, "CODE_EXPIRED", "验证码已过期")
    IS_EXISTS_PHONE = RSINFO.err(10002006, "IS_EXISTS_PHONE", "该手机号已绑定其他账户")
    INVALID_PHONE_FOR_BIND_WECHAT = RSINFO.err(
        10002007, "INVALID_PHONE_FOR_BIND_WECHAT", "手机号绑定失败"
    )
    CURRENT_USER_NOT_BIND_WECHAT = RSINFO.err(
        10002008, "CURRENT_USER_NOT_BIND_WECHAT", "当前用户未绑定微信"
    )

    INVALID_CAPTCHA = RSINFO.err(10003000, "INVALID_CAPTCHA", "图形验证码不正确")

    SPACE_INVITATION_NO_AVAILABLE_CODE = RSINFO.err(
        10004000, "SPACE_INVITATION_NO_AVAILABLE_CODE", "没有可用的邀请码可以生成"
    )

    # http_base请求
    HTTPX_GET_FAILED = RSINFO.err(10005000, "HTTPX_GET_FAILED", "httpx get请求失败")
    HTTPX_POST_FAILED = RSINFO.err(10005001, "HTTPX_POST_FAILED", "httpx post请求失败")

    # space
    SPACE_INVITATION_CODE_EXPIRED = RSINFO.err(
        10007000, "SPACE_INVITATION_CODE_EXPIRED", "邀请码已过期"
    )
